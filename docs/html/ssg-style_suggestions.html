<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DetectorGraph: Style Tips - Patterns, Anti-Patterns &amp; Suggestions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DetectorGraph
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Style Tips - Patterns, Anti-Patterns &amp; Suggestions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ssg-style-intro">Introduction</a></li>
<li class="level1"><a href="#ssg-naming-topicstates">Naming TopicStates</a></li>
<li class="level1"><a href="#ssg-too-big-too-small-tss">Too Big vs. Too Small TopicStates</a><ul><li class="level2"><a href="#ssg-type-is-data">Type is data</a></li>
<li class="level2"><a href="#ssg-empty-topics">Trivial/Empty Topics are sometimes fine.</a></li>
<li class="level2"><a href="#ssg-atomic-change">Variables/bits/data that change together atomically belong together.</a></li>
<li class="level2"><a href="#ssg-mutually-exclusive">Mutually exclusive states also belong together.</a></li>
<li class="level2"><a href="#ssg-everything-is-a-service">Topics are APIs</a></li>
</ul>
</li>
<li class="level1"><a href="#ssg-dependencies">Detectors and Topics Dependencies</a></li>
<li class="level1"><a href="#ssg-caching-topicstate">Caching/Saving TopicStates is the right solution!</a></li>
<li class="level1"><a href="#ssg-settings-topicstate">Settings are also Topics</a></li>
<li class="level1"><a href="#ssg-flat-evaluates">Flat Evaluates vs. Indirect and/or nested member methods</a></li>
<li class="level1"><a href="#ssg-concentrators-aggregations">Concentrators &amp; Aggregations</a></li>
<li class="level1"><a href="#ssg-resuming-state">Resuming State</a></li>
<li class="level1"><a href="#ssg-explicit-calls-to-evaluate">Explicit calls to Evaluate()?</a></li>
<li class="level1"><a href="#ssg-initial-states">Publishing Initial States</a></li>
<li class="level1"><a href="#ssg-namespaces">Usage of Namespaces</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ssg-style-intro"></a>
Introduction</h1>
<p>This page contains a set of guidelines &amp; rules of thumb that we accumulated after 3+ years of using <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a>. These are aimed at keeping software design constrained in a way that best takes advantage of the <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> framework, its expressibility and modeling power.</p>
<h1><a class="anchor" id="ssg-naming-topicstates"></a>
Naming TopicStates</h1>
<p>Topics carry <code>TopicStates</code>. <code>TopicStates</code> can express states, events/transitions, operations/requests &amp; responses. Examples are:</p><ul>
<li><code>FooState</code></li>
<li><code>BarSample</code> when Bar is a sensor.</li>
<li><code>FooBarState</code>, produced by a <code>FooBarDetector</code>. Note that <code>FooBarDetectorState</code> is not encouraged as it ties the producer with it's product - but it can be ok in some very specific cases.</li>
<li><code>SomethingRequest</code> &amp; <code>SomethingResponse</code> when implementing a RPC Request/Response pattern.</li>
<li><code>FooBarSettings</code> for settings that determine how <code>FooBarDetector</code> (and by extension <code>FooBarState</code>) behave. See also <a class="el" href="ssg-style_suggestions.html#ssg-settings-topicstate">Settings</a>.</li>
</ul>
<h1><a class="anchor" id="ssg-too-big-too-small-tss"></a>
Too Big vs. Too Small TopicStates</h1>
<p>Hypothetically, the entirety of a system's state could be contained on a single TopicState that is Subscribed to &amp; published to by every detector. Conversely, one could split every individual bit (pardon the pun) of data into separate TopicStates and have detectors only subscribe to the bits necessary to form the data it depends on. Both are clearly poor separations-of-concern choices and are clear misuses of the <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> framework - obviously the sweet spot lies in between, but where? Below are a set of guidelines for partitioning Topics:</p>
<h2><a class="anchor" id="ssg-type-is-data"></a>
Type is data</h2>
<dl class="section user"><dt>A rose by any other name would smell as sweet</dt><dd>â€” Juliet</dd></dl>
<p>Topics can be seen as <em>named buses</em> where the <em>name</em> is the TopicState's type - and since Subscriptions are to a <em>type</em>, the <em>type</em> itself has 'meaning'. Thus a TopicState's <em>type</em> carries both a <em>name</em> and the data structure/fields inside the TopicState. Often it is appropriate to have different <em>names</em> for otherwise equivalent data structures - that is fine and encouraged.</p>
<p>This can be the case when an application has different topics for filtered vs. unfiltered data for a sensor; or some data through different layers of verification/processing.</p>
<p>There are two ways of accomplishing this; composition or inheritance. Composition is often preferable over inheritance as it gives more flexibility but both should be considered and are possible.</p>
<p>Composition example (from <a class="el" href="robotlocalization_8cpp.html">Robot Localization</a>): </p><div class="fragment"><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="keyword">struct </span>KalmanState</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;{</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    KalmanState() : pose(Vector3d::Zero()), error(Matrix3d::Zero()) {}</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    KalmanState(Vector3d aPose, Matrix3d aError) : pose(aPose), error(aError) {}</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    Vector3d pose;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    Matrix3d error;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;};</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment">//! [Mutually Atomic Variables]</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment"></span><span class="keyword">struct </span>LocalizationBelief : <span class="keyword">public</span> TopicState</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;{</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    LocalizationBelief() : timestampMs(), state() {}</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    LocalizationBelief(uint64_t ts, <span class="keyword">const</span> KalmanState&amp; aState) : timestampMs(ts), state(aState) {}</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    LocalizationBelief(uint64_t ts, <span class="keyword">const</span> Vector3d&amp; aPose, <span class="keyword">const</span> Matrix3d&amp; aError) : timestampMs(ts), state(aPose, aError) {}</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    uint64_t timestampMs;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    KalmanState state;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;};<span class="comment"></span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">//! [Mutually Atomic Variables]</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="keyword">struct </span>GPSPosition : <span class="keyword">public</span> TopicState</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;{</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    GPSPosition() : timestampMs(), state() {}</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    GPSPosition(uint64_t ts, <span class="keyword">const</span> KalmanState&amp; aState) : timestampMs(ts), state(aState) {}</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    uint64_t timestampMs;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    KalmanState state;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;};</div></div><!-- fragment --><p> Inheritance examples From <a class="el" href="fancyvendingmachine_8cpp.html">Fancy Vending Machine</a>: </p><div class="fragment"><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="keyword">struct </span>RefillChange : <span class="keyword">public</span> <a class="code" href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a>, <span class="keyword">public</span> ChangeAlgo::CoinStock</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;{</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    RefillChange() {}</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    RefillChange(<span class="keyword">const</span> ChangeAlgo::CoinStock&amp; stock) : ChangeAlgo::CoinStock(stock) {}</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;};</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="keyword">struct </span>ReleaseCoins : <span class="keyword">public</span> <a class="code" href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a>, <span class="keyword">public</span> ChangeAlgo::Draw</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;{</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    ReleaseCoins() {}</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    ReleaseCoins(<span class="keyword">const</span> ChangeAlgo::Draw&amp; draw) : ChangeAlgo::Draw(draw) {}</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;};</div><div class="ttc" id="structDetectorGraph_1_1TopicState_html"><div class="ttname"><a href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a></div><div class="ttdoc">Base struct for topic data types. </div><div class="ttdef"><b>Definition:</b> <a href="topicstate_8hpp_source.html#l00052">topicstate.hpp:52</a></div></div>
</div><!-- fragment --><p>From <a class="el" href="beatmachine_8cpp.html">Beat Machine</a>: </p><div class="fragment"><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="keyword">struct </span>SongLine</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;{</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    std::string line;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    SongLine() : line() {}</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    SongLine(<span class="keyword">const</span> std::string&amp; aLine) : line(aLine) {}</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="keyword">friend</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, SongLine s) { <span class="keywordflow">return</span> os &lt;&lt; s.line; }</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;};</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="keyword">struct </span>SongThemeState : <span class="keyword">public</span> <a class="code" href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a>, <span class="keyword">public</span> SongLine</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;{</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    SongThemeState() {}</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    SongThemeState(<span class="keyword">const</span> std::string&amp; aLine) : SongLine(aLine) {}</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;};</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="keyword">struct </span>DontThemeState : <span class="keyword">public</span> <a class="code" href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a>, <span class="keyword">public</span> SongLine</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;{</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    DontThemeState() {}</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    DontThemeState(<span class="keyword">const</span> std::string&amp; aLine) : SongLine(aLine) {}</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;};</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="keyword">struct </span>RememberState : <span class="keyword">public</span> <a class="code" href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a>, <span class="keyword">public</span> SongLine</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;{</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    RememberState() {}</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    RememberState(<span class="keyword">const</span> std::string&amp; aLine) : SongLine(aLine) {}</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;};</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="keyword">struct </span>ThenYouState : <span class="keyword">public</span> <a class="code" href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a>, <span class="keyword">public</span> SongLine</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;{</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    ThenYouState() {}</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    ThenYouState(<span class="keyword">const</span> std::string&amp; aLine) : SongLine(aLine) {}</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;};</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="keyword">struct </span>PlaybackState : <span class="keyword">public</span> <a class="code" href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;{</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="keywordtype">bool</span> autoplay;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    PlaybackState(<span class="keywordtype">bool</span> aAutoplay = <span class="keyword">false</span>) : autoplay(aAutoplay) {}</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;};</div><div class="ttc" id="structDetectorGraph_1_1TopicState_html"><div class="ttname"><a href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a></div><div class="ttdoc">Base struct for topic data types. </div><div class="ttdef"><b>Definition:</b> <a href="topicstate_8hpp_source.html#l00052">topicstate.hpp:52</a></div></div>
</div><!-- fragment --><p> Inheritance can save you some typing and be OK when literally all you're changing is the type 'name' and when you know the data structure will never change and when the 'is a' relationship holds strongly. Inheritance is the lazy approach but that you'll likely have to ditch (at great expense possibly) at some point in the future.</p>
<h2><a class="anchor" id="ssg-empty-topics"></a>
Trivial/Empty Topics are sometimes fine.</h2>
<p>Sometimes all a topic needs to express is the fact that <em>it updated</em>, that it <em>happened</em> or any other purely unary signals:</p>
<p>From <a class="el" href="trivialvendingmachine_8cpp.html">Trivial Vending Machine</a>: </p><div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="keyword">struct </span>CoinInserted : <span class="keyword">public</span> <a class="code" href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;{</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;};</div><div class="ttc" id="structDetectorGraph_1_1TopicState_html"><div class="ttname"><a href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a></div><div class="ttdoc">Base struct for topic data types. </div><div class="ttdef"><b>Definition:</b> <a href="topicstate_8hpp_source.html#l00052">topicstate.hpp:52</a></div></div>
</div><!-- fragment --><p>From <a class="el" href="fancyvendingmachine_8cpp.html">Fancy Vending Machine</a>: </p><div class="fragment"><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="keyword">struct </span>MoneyBackButton : <span class="keyword">public</span> <a class="code" href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;{</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;};</div><div class="ttc" id="structDetectorGraph_1_1TopicState_html"><div class="ttname"><a href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a></div><div class="ttdoc">Base struct for topic data types. </div><div class="ttdef"><b>Definition:</b> <a href="topicstate_8hpp_source.html#l00052">topicstate.hpp:52</a></div></div>
</div><!-- fragment --> <h2><a class="anchor" id="ssg-atomic-change"></a>
Variables/bits/data that change together atomically belong together.</h2>
<p>Examples:</p>
<p>A product and its new price: </p><div class="fragment"><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="keyword">struct </span>PriceUpdate : <span class="keyword">public</span> <a class="code" href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;{</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    ProductIdType productId;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    <span class="keywordtype">int</span> priceCents;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    PriceUpdate(ProductIdType aProduct = kProductIdTypeNone, <span class="keywordtype">int</span> aPrice = 0) : productId(aProduct), priceCents(aPrice) {}</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;};</div><div class="ttc" id="structDetectorGraph_1_1TopicState_html"><div class="ttname"><a href="structDetectorGraph_1_1TopicState.html">DetectorGraph::TopicState</a></div><div class="ttdoc">Base struct for topic data types. </div><div class="ttdef"><b>Definition:</b> <a href="topicstate_8hpp_source.html#l00052">topicstate.hpp:52</a></div></div>
</div><!-- fragment --><p> A robot's pose and a timestamp: </p><div class="fragment"><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="keyword">struct </span>LocalizationBelief : <span class="keyword">public</span> TopicState</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;{</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    LocalizationBelief() : timestampMs(), state() {}</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    LocalizationBelief(uint64_t ts, <span class="keyword">const</span> KalmanState&amp; aState) : timestampMs(ts), state(aState) {}</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    LocalizationBelief(uint64_t ts, <span class="keyword">const</span> Vector3d&amp; aPose, <span class="keyword">const</span> Matrix3d&amp; aError) : timestampMs(ts), state(aPose, aError) {}</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    uint64_t timestampMs;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    KalmanState state;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;};</div></div><!-- fragment --> <h2><a class="anchor" id="ssg-mutually-exclusive"></a>
Mutually exclusive states also belong together.</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>DoorState : <span class="keyword">public</span> TopicState</div><div class="line">{</div><div class="line">    <span class="keyword">enum</span> OpenCloseState {</div><div class="line">        kOpen,</div><div class="line">        kClosed,</div><div class="line">    };</div><div class="line"></div><div class="line">    OpenCloseState state;</div><div class="line">};</div></div><!-- fragment --><p>This also includes Topics used to drive (or driven by) a finite state machine.</p>
<h2><a class="anchor" id="ssg-everything-is-a-service"></a>
Topics are APIs</h2>
<p>Another rule of thumb is to think of Topics as APIs themselves; they should be as general as possible. More general TopicStates tend to better isolate concerns and be more reusable in the future. In general, when creating a topic don't name it with respect to what it'll be used; instead try to name it according to what information it carries.</p>
<h1><a class="anchor" id="ssg-dependencies"></a>
Detectors and Topics Dependencies</h1>
<p>One of the main advantages of using <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> is a very clear isolation of dependencies &amp; concerns. To maintain those advantages <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> code should comply with the following rules:</p><ul>
<li>Detectors should not have any dependencies on any other Detectors: no data-structure dependencies nor runtime/callgraph dependencies.</li>
<li>Detectors can depend on any number of Topics; ideally only the Topics it Subscribes or Publishes.</li>
<li>Topics can depend on other Topics for data-structures but should never inherit from other Topics.</li>
<li>Detectors should do no I/O nor should they talk to other dynamic software modules; debug/text logging is probably the one notable exception. It's totally fine to use a math library or an algorithm-specific library but it's not OK to communicate across threads accessing a singleton outside the <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a>.</li>
</ul>
<h1><a class="anchor" id="ssg-caching-topicstate"></a>
Caching/Saving TopicStates is the right solution!</h1>
<p>Sometimes detectors only need a the information in <code>TopicStateA</code> when evaluating <code>TopicStateB</code>. It may seem like Subscribing to <code>TopicStateA</code> is overkill - but it's not. Remember that <code>Evaluate(TopicStateA)</code>s is only called when <code>TopicStateA</code> changes and thus there's no runtime penalty on having multiple <code>Evaluate()</code>s that are called rarely.</p>
<p>The recommended pattern here is:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FooBarDetector : <span class="keyword">public</span> SubscriberInterface&lt;Foo&gt;, <span class="keyword">public</span> SubscriberInterface&lt;Bar&gt;, <span class="keyword">public</span> Publisher&lt;FooBarState&gt;</div><div class="line">{</div><div class="line"><span class="comment">//...</span></div><div class="line">    <span class="keywordtype">void</span> Evaluate(<span class="keyword">const</span> Foo&amp; aNewFoo)</div><div class="line">    {</div><div class="line">        mCurrentFoo = aNewFoo;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Evaluate(<span class="keyword">const</span> Bar&amp; aNewBar)</div><div class="line">    {</div><div class="line">        Publish(FooBar(mCurrentFoo, aNewBar));</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Foo mCurrentFoo;</div><div class="line">};</div></div><!-- fragment --><p>Note that most <code>TopicStates</code> are small bits of data and thus copying by value should always be efficient. In cases where a <code>TopicState</code> contains a lot of data, such that copy-by-value would be a problem, it is the responsibility of that <code>TopicState</code>s implementation to implement an appropriate shallow copies scheme. For an example of that see <a class="el" href="portuguesetranslator_8cpp.html#ex-pt-sharing-mem">Sharing Memory across TopicStates</a>.</p>
<h1><a class="anchor" id="ssg-settings-topicstate"></a>
Settings are also Topics</h1>
<p>Topics should be used to convey settings as well, and caching them is the way to go (see <a class="el" href="ssg-style_suggestions.html#ssg-caching-topicstate">Caching/Saving TopicStates is the right solution!</a>) </p><div class="fragment"><div class="line"><span class="keyword">class </span>TooHotDetector : <span class="keyword">public</span> SubscriberInterface&lt;TooHotThreshold&gt;, <span class="keyword">public</span> SubscriberInterface&lt;Temperature&gt;, <span class="keyword">public</span> Publisher&lt;TooHot&gt;</div><div class="line">{</div><div class="line">    <span class="keywordtype">void</span> Evaluate(<span class="keyword">const</span> TooHotThreshold&amp; aThreshold)</div><div class="line">    {</div><div class="line">        mCurrentThreshold = aThreshold;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Evaluate(<span class="keyword">const</span> Temperature&amp; aTemperature)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (aTemperature.value &gt; mCurrentThreshold.value)</div><div class="line">        {</div><div class="line">            Publish(TooHot());</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    TooHotThreshold mCurrentThreshold;</div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="ssg-flat-evaluates"></a>
Flat Evaluates vs. Indirect and/or nested member methods</h1>
<dl class="section user"><dt>Flat is better than nested</dt><dd>â€” Zen of Python</dd></dl>
<p>When reading a Detector's code some of the first concepts a reader tries to grasp is the causality between input TopicStates and output ones - simplifying the answer to this question is one of the design goals of <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> and one of the main reasons one would use the framework. To simplify this further one should keep in mind that the path between Evaluate() methods and Publish() calls should be as straightforward as possible. One way to achieve that is to reduce call stack between the two to a minimal. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TooHotDetector : <span class="keyword">public</span> SubscriberInterface&lt;Temperature&gt;, <span class="keyword">public</span> Publisher&lt;TooHot&gt;</div><div class="line">{</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keywordtype">void</span> Evaluate(<span class="keyword">const</span> Temperature&amp; temp)</div><div class="line">    {</div><div class="line">        PublishTooHotIfTooHot(temp);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> PublishTooHotIfTooHot(<span class="keyword">const</span> Temperature&amp; temp)</div><div class="line">    {</div><div class="line">        <span class="comment">// do a bunch of stuff with Temperature</span></div><div class="line">        <span class="keywordflow">if</span> (...)</div><div class="line">        {</div><div class="line">            Publish(TooHot(<span class="keyword">true</span>));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            Publish(TooHot(<span class="keyword">false</span>));</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>versus:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TooHotDetector : <span class="keyword">public</span> SubscriberInterface&lt;Temperature&gt;, <span class="keyword">public</span> Publisher&lt;TooHot&gt;</div><div class="line">{</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keywordtype">void</span> Evaluate(<span class="keyword">const</span> Temperature&amp; temp)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">bool</span> tooHot = IsTooHot(temp);</div><div class="line">        Publish(TooHot(tooHot));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> IsTooHot(<span class="keyword">const</span> Temperature&amp; temp)</div><div class="line">    {</div><div class="line">        <span class="comment">// do a bunch of stuff with Temperature</span></div><div class="line">        <span class="keywordflow">return</span> isTooHot;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>In the first example a reader must follow &amp; comprehend what PublishTooHotIfTooHot does before they can conclude that <code>TooHotDetector</code> will always publish 1 (and only one) <code>TooHot</code> state per input sample. In the second example that relationship is trivial. The intent is to have direct paths from an <code>Evaluate()</code> (or <code>BeginEvaluation()</code>, <code>CompleteEvaluation()</code>) to <code>Publish</code> (or <code>FuturePublish()</code>, <code>PublishOnTimeout()</code>).</p>
<h1><a class="anchor" id="ssg-concentrators-aggregations"></a>
Concentrators &amp; Aggregations</h1>
<p>In many cases detectors provide an accumulated/aggregated view of a set of TopicStates. The simplest &amp; more readable way we found to do this was based on variations of the pattern below:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AggregatorDetector : <span class="keyword">public</span> Detector,</div><div class="line">    <span class="keyword">public</span> SubscriberInterface&lt;BoosterState&gt;,</div><div class="line">    <span class="keyword">public</span> SubscriberInterface&lt;RetrofireState&gt;,</div><div class="line">    <span class="keyword">public</span> SubscriberInterface&lt;FlightDynamicsState&gt;,</div><div class="line">    <span class="keyword">public</span> Publisher&lt;LiftOff&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">enum</span> CheckList</div><div class="line">    {</div><div class="line">        kBooster = 0,</div><div class="line">        kRetrofireState,</div><div class="line">        kFlightDynamicsState,</div><div class="line"></div><div class="line">        <span class="comment">// last</span></div><div class="line">        kCheckListCount</div><div class="line">    };</div><div class="line">    std::bitset&lt;kCheckListCount&gt; mCheckList;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keywordtype">void</span> Evaluate(<span class="keyword">const</span> BoosterState&amp; aBoosterState) { mCheckList[kBooster] = (aBoosterState.Go()) }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Evaluate(<span class="keyword">const</span> RetrofireState&amp; aRetroState) { mCheckList[kRetrofireState] = (aRetroState.Go()) }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Evaluate(<span class="keyword">const</span> FlightDynamicsState&amp; aFidoState) { mCheckList[kFlightDynamicsState] = (aFidoState.Go()) }</div><div class="line"></div><div class="line">    <span class="comment">// ..</span></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> CompleteEvaluation() {</div><div class="line">        <span class="keywordflow">if</span> (mCheckList.all()) {</div><div class="line">            Publish(LiftOff());</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Note the use of CompleteEvaluation to make the general conditional check regardless what inputs have changed.</p>
<h1><a class="anchor" id="ssg-resuming-state"></a>
Resuming State</h1>
<p>The best way we found to resume graph states is to use a specific <code>TopicState</code> (<code>ResumeFromSnapshotTopicState</code>) that contains a de-serialized version of the latest preserved StateSnapshot. Each detector that needs to resume its state then has a chance of inspecting the entire snapshot to reconstruct its state.</p>
<p>Initially it was thought that state resuming could be done simply be re-publishing the stored <code>TopicStates</code> but since most Detectors keep state they'd have to subscribe to their own outputs - in a way that the Resume operation would go in reverse order than the normal topological sort of the graph. That was deemed overly complex &amp; contrived and would greatly increase code complexity.</p>
<p>Instead we opted of giving detectors this <em>know-all</em> single chance to restore their state &amp; re-publish any resumed state <code>TopicStates</code> as necessary.</p>
<p>For a full example see <a class="el" href="resuminggraph_8cpp.html">Resuming Counter</a> ( Basic Counter Graph with persistent storage. )</p>
<h1><a class="anchor" id="ssg-explicit-calls-to-evaluate"></a>
Explicit calls to Evaluate()?</h1>
<p>Detector's <code>Evaluate()</code> method calls are central to <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> applications. They are called by the framework in a very specific and coordinated manner (<code>BeginEvaluation()-&gt;n*Evaluate()-&gt;CompleteEvaluation()</code>).</p>
<p>In some situations it may seem appropriate to explicitly/manually call <code>Evaluate(X)</code> from within another method of a Detector to process a specific (e.g. initial) version of X - that's sometimes an <em>anti-pattern</em>. When a reader encounters an <code>Evaluate(Z)</code> method he/she expects that to only be called when Z has changed - and most of the times that's also what log messages inside <code>Evaluate(Z)</code> will have log readers believe. By manually calling <code>Evaluate()</code> you break that expectation.</p>
<p>More than once this had led debugging along a completely wrong path and makes <code>Detector</code>s program flow less flat and more convoluted. If a single set of operations is necessary for multiple different inputs it is better to implement that as a separate function and have that called from both <code>Evaluate()</code>s.</p>
<h1><a class="anchor" id="ssg-initial-states"></a>
Publishing Initial States</h1>
<p>Detectors do not have a specific mechanism for publishing their initial states/prime outputs.</p>
<p>Detectors are free &amp; encouraged to use their constructors to initialize data members and state but calling any <code>Publish()</code> (<code>FuturePublish()</code>, <code>PublishOnTimeout()</code>) from within the constructor is not supported/allowed (I'd consider it a bug).</p>
<p>This is somewhat intentional - sometimes allowing program flow to diverge a lot between first &amp; not-first instances hurts readability and creates more code for the same functionality. By limiting <code>Publish()</code> calls to <code>Evaluate()</code> calls' bodies the program flow through the graph remains consistent throughout the entire life of DetectorGraphs (i.e. evaluations always follow topological sorts &amp; always happen due to a Topic posting "from the outside").</p>
<p>Instead the suggested pattern going forward is to always rely on <code>ResumeFromSnapshotTopicState</code> and make sure your implementation provides an "empty" <code>ResumeFromSnapshotTopicState</code> when a de-serialized one isn't available.</p>
<p>In the past we have used a specific <code>TopicState</code> (say <code>DetectorGraphInitialized</code>) that detectors can subscribe to to be notified when the system boots and publish any new state they may need to. That solution is redundant and not as canonical as the solution described above so it's not recommended anymore.</p>
<p>For a full example see <a class="el" href="resuminggraph_8cpp.html">Resuming Counter</a> ( Basic Counter Graph with persistent storage. )</p>
<h1><a class="anchor" id="ssg-namespaces"></a>
Usage of Namespaces</h1>
<p>All <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> names are inside the <code><a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a></code> namespace. Within an application it is suggested to have a single namespace reserved for all your Detectors &amp; TopicStates; that allows you to use short names &amp; appropriate names for those without risk of collision. We have also used separate namespaces for TopicsStates &amp; Detectors but that didn't yield much readability or expressibility. Things to keep in mind when making your decision:</p>
<ul>
<li>Detectors' names are used not used often in code.</li>
<li>Detectors have a dependency on Topics.</li>
<li>Topics' names are used very often in code.</li>
<li>Topics do not depend on detectors or on any other code modules.</li>
<li>Although they can depend on reusable data structures, they should strive to be self-contained. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
