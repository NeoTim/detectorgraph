<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DetectorGraph: Memory Duplication Discussion</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DetectorGraph
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Memory Duplication Discussion </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#memory-intro">Introduction</a></li>
<li class="level1"><a href="#memory-smartptr">Memory Efficient TopicStates</a></li>
<li class="level1"><a href="#data-passing">Data-Passing Discussion</a><ul><li class="level2"><a href="#memory-rationale">Data-Passing Rationale</a></li>
<li class="level2"><a href="#memory-complexity">Overview of memory complexity</a></li>
<li class="level2"><a href="#memory-policy">When is this a problem?</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="memory-intro"></a>
Introduction</h1>
<blockquote class="doxtable">
<p>The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming. &ndash; <em>Donald Knuth</em> </p>
</blockquote>
<p>The main design goal for the <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> library is to guarantee decoupling of different logic &amp; data units from each other. That is achieved by separating logic units into different detectors and only allowing data transfer through topics. Additionally, the framework provides a guarantee that any new data is evaluated following the graph's topological sort.</p>
<p>To preserve those guarantees, all logic dependencies of a <a class="el" href="classDetectorGraph_1_1Detector.html" title="A unit of logic in a DetectorGraph. ">Detector</a> should be carried by Topics. One could code a detector that accesses other resources than Topics but that grossly violates the intended coding pattern.</p>
<p>Those constraints force Detectors to often keep copies of the latest <a class="el" href="structDetectorGraph_1_1TopicState.html" title="Base struct for topic data types. ">TopicState</a> in a <a class="el" href="classDetectorGraph_1_1Topic.html" title="Manage data and its handler. ">Topic</a> they depend on. This is normally not a problem - and is desirable - since it makes code very readable by limitting the number of edge cases one needs to consider when writing/reading code.</p>
<p>In situations where the data in a <a class="el" href="structDetectorGraph_1_1TopicState.html" title="Base struct for topic data types. ">TopicState</a> becomes too large to be copied around, smarter TopicStates can be made to preserve the coding pattern while at the same time being memory-efficient. For more on that see <a class="el" href="memory_duplication.html#memory-smartptr">Memory Efficient TopicStates</a>.</p>
<p>For an in-depth discussion of where/when/why data is copied and the rationale behind it see <a class="el" href="memory_duplication.html#data-passing">Data-Passing Discussion</a>.</p>
<h1><a class="anchor" id="memory-smartptr"></a>
Memory Efficient TopicStates</h1>
<p>When a <a class="el" href="structDetectorGraph_1_1TopicState.html" title="Base struct for topic data types. ">TopicState</a> is published (into the graph of between detectors) it is copied by value. That calls the copy-constructor (or the assignment operator in the lite version of the framework). This lets the writer of any <a class="el" href="structDetectorGraph_1_1TopicState.html" title="Base struct for topic data types. ">TopicState</a> control really what is copied and how.</p>
<p>For example, consider an application that uses a large buffer:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>RawImage {</div><div class="line">    uint8_t data[4096*4096];</div><div class="line">};</div></div><!-- fragment --><p>Wrapping that object with a smart pointer (<code>shared_ptr</code>) would already save us from copying the entire buffer around while still keeping track of when to dispose of it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;shared_ptr.hpp&quot;</span> <span class="comment">// In DetectorGraph&#39;s include folder</span></div><div class="line"></div><div class="line"><span class="comment">// Simple TopicState that wraps a RawImage with a shared_ptr.</span></div><div class="line"><span class="keyword">struct </span>CameraNewFrame : <span class="keyword">public</span> TopicState {</div><div class="line">    ptr::shared_ptr&lt;RawImage&gt; image;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// At the original creator of the buffer:</span></div><div class="line"><span class="comment">// (either inside or outside the Graph)</span></div><div class="line">{</div><div class="line">    CameraNewFrame newFrame;</div><div class="line">    <span class="comment">// Create managed storage</span></div><div class="line">    newFrame.image = ptr::shared_ptr&lt;RawImage&gt;(<span class="keyword">new</span> RawImage());</div><div class="line"></div><div class="line">    <span class="comment">// Fill it in some way</span></div><div class="line">    memset(newFrame.image-&gt;data, 42, <span class="keyword">sizeof</span>(newFrame.image-&gt;data));</div><div class="line"></div><div class="line">    <span class="comment">// If from within a Detector:</span></div><div class="line">    Publish(newFrame);</div><div class="line"></div><div class="line">    <span class="comment">// Or, if from outside the graph:</span></div><div class="line">    graph.<a class="code" href="classDetectorGraph_1_1Graph.html#aeab252a7ba121ea31750822bc0faf111">PushData</a>&lt;CameraNewFrame&gt;(newFrame);</div><div class="line">}</div></div><!-- fragment --><p>For a full example of a memory efficient <a class="el" href="structDetectorGraph_1_1TopicState.html" title="Base struct for topic data types. ">TopicState</a> see this <a class="el" href="portuguesetranslator_8cpp.html">example. </a></p>
<h1><a class="anchor" id="data-passing"></a>
Data-Passing Discussion</h1>
<p>As a general rule, <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> passes <code>const</code> references where possible and by-value copies whenever necessary.</p>
<p>Given the nature of the framework, two patterns of data passing are evident:</p><ul>
<li>Pass and Forget (used on <a class="el" href="classDetectorGraph_1_1GraphInputDispatcher.html#af89e5aed3fc870f9bc8e6a2dac9953dc">GraphInputDispatcher::GraphInputDispatcher</a> when calling <a class="el" href="classDetectorGraph_1_1Graph.html#aeab252a7ba121ea31750822bc0faf111">Graph::PushData</a> and <a class="el" href="classDetectorGraph_1_1Topic.html#a2c61e215453ae8bfac9f9c79fe3ab236">Topic::Publish</a>) where data will 'wait' on a queue or topic for some time after the caller has moved forward.</li>
<li>Pass for Inspection (used on <a class="el" href="classDetectorGraph_1_1SubscriberInterface.html#aa6ff973e38d74612e60d91f104daa624">SubscriberInterface::Evaluate</a> on a detector)</li>
<li>Cross-type Aggregation for Inspection (used on <a class="el" href="classDetectorGraph_1_1Graph.html#ae2eea42e89f2710b5e242e3db35ad905">Graph::GetOutputList</a>)</li>
</ul>
<p>On "pass and forget" scenarios, copies are internally used to ensure valid data is delivered in the future. This gives the user freedom to control how copies are made through the implementation of a custom Copy Constructor. That way it's up to the implementation of each <a class="el" href="structDetectorGraph_1_1TopicState.html" title="Base struct for topic data types. ">TopicState</a> to decide how copies are made with the simplest/safest option being the default.</p>
<p>On "Pass for Inspection" scenarios <code>const</code> references are used. The consumer (e.g. detector) shall inspect the value and may or may not create its own cached copy.</p>
<p>On "Cross-type Aggregation" scenarios <code>TopicState*</code> are necessary due to the polymorphic nature of <code><a class="el" href="structDetectorGraph_1_1TopicState.html" title="Base struct for topic data types. ">TopicState</a></code> so a constant list of <code>const TopicState*</code> is returned.</p>
<h2><a class="anchor" id="memory-rationale"></a>
Data-Passing Rationale</h2>
<p>As mentioned above, data is copied in the cases where not copying would mean leaving the responsability of data lifecycle management to the producer of such data instead of the framework. That seemed counter intuitive from the perspective of a <a class="el" href="classDetectorGraph_1_1Publisher.html" title="Base class that implements a Publisher behavior. ">Publisher</a> that normally prefers a "fire and forget" logic. By pushing this decision to the framework we reduce the overall complexity of the application itself.</p>
<h2><a class="anchor" id="memory-complexity"></a>
Overview of memory complexity</h2>
<p>An <em>external</em> <a class="el" href="structDetectorGraph_1_1TopicState.html" title="Base struct for topic data types. ">TopicState</a> that travels through the framework is copied twice:</p><ul>
<li>into the graph input queue - the data packet is not in the graph yet and can continue to wait in the input queue until enough evaluations of the graph dequeue it. Beind held by <a class="el" href="classDetectorGraph_1_1GraphInputDispatcher.html#af89e5aed3fc870f9bc8e6a2dac9953dc">GraphInputDispatcher::GraphInputDispatcher</a>.</li>
<li>into its designated topic. Via <a class="el" href="classDetectorGraph_1_1Topic.html#a2c61e215453ae8bfac9f9c79fe3ab236">Topic::Publish</a>.</li>
</ul>
<p>Note that this two copies do not coexist and that the copy from the input queue into a topic takes advantage of the same program flow used for in-graph publishing and so simplifying a lot the overall design.</p>
<p>An <em>internal</em> <a class="el" href="structDetectorGraph_1_1TopicState.html" title="Base struct for topic data types. ">TopicState</a> that is generated in a detector is copied once:</p><ul>
<li>into its designated topic.</li>
</ul>
<p>In addition to that, TopicStates are copied each time a <a class="el" href="classDetectorGraph_1_1Detector.html" title="A unit of logic in a DetectorGraph. ">Detector</a> keeps their own local copy of the <a class="el" href="structDetectorGraph_1_1TopicState.html" title="Base struct for topic data types. ">TopicState</a>.</p>
<h2><a class="anchor" id="memory-policy"></a>
When is this a problem?</h2>
<p>Given that the framework does copy data:</p><ul>
<li>When a <a class="el" href="structDetectorGraph_1_1TopicState.html" title="Base struct for topic data types. ">TopicState</a> is something really large; an image, sound clip, etc.</li>
<li>If optimizing for memory, any packets larger than a <em>ptr</em> is an optimization opportunity.</li>
</ul>
<p>In those cases, a "smart TopicState" can abstract away the memory management for an object that is not copied around at all. See section <a class="el" href="memory_duplication.html#memory-smartptr">Memory Efficient TopicStates</a> for examples on how to do that. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
