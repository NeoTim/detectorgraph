<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DetectorGraph: DetectorGraph: Formal C++ applications with logic/data separation, automatic dependency injection and data passing.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DetectorGraph
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a>: Formal C++ applications with logic/data separation, automatic dependency injection and data passing. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/google/detectorgraph"></a></p>
<p><a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> is a framework for writing programs in a formal graph topology. This can be used to write applications with multiple interdependent algorithms, applications' data models, general business logic or all of that combined. The framework uses a formal distinction between data (Topics) and transformations/logic (Detectors). It natively provides dependency injection, strict type-safety and provides loose coupling between Detectors by formalizing the touch points as Topics. It forces an intuitive (albeit unusual) programming paradigm that results in highly readable, maintainable &amp; testable code.</p>
<p>This is not an officially supported Google product.</p>
<p><a href="https://google.github.io/detectorgraph/">Full online documentation</a>.</p>
<p>Note that the cross-reference links in this page are only rendered in the Doxygen version of the documentation (see <a href="#building">Building</a>). You can also navigate the web version of the documentation hosted at <a href="https://google.github.io/detectorgraph/">https://google.github.io/detectorgraph/</a>.</p>
<h2>Getting Started</h2>
<h2>Usage</h2>
<p>Applications are written as a combination of <em>Detectors</em> and <em>Topics</em>.</p>
<p><em>Topics</em> carry a particular signal/data-type: </p><pre class="fragment">struct FooSensorData : public DetectorGraph::TopicState
{
    int x;
}
</pre><p><em>Detectors</em> encode a logical unit that describes the transformation from any number of <em>Topics</em> to any number of other <em>Topics</em>: </p><pre class="fragment">class BarThresholdDetector : public DetectorGraph::Detector,
    public DetectorGraph::SubscriberInterface&lt;FooSensorData&gt;,
    public DetectorGraph::Publisher&lt;BazThresholdCrossing&gt;
{
    BarThresholdDetector(DetectorGraph::Graph* graph) : DetectorGraph::Detector(graph)
    {
        Subscribe&lt;FooSensorData&gt;(this);
        SetupPublishing&lt;BazThresholdCrossing&gt;(this);
    }
    virtual void Evaluate(const FooSensorData&amp; data)
    {
        if (data.x &gt; 100)
        {
            Publish(BazThresholdCrossing(data.x));
        }
    }
}
</pre><p><em>DetectorGraphs</em> are created by adding any number of <em>Detectors</em> to a <em>Graph</em>. All necessary <em>Topics</em> are created on demand and supplied via Dependency Injection. </p><pre class="fragment">DetectorGraph::Graph graph;
BarThresholdDetector detector(&amp;graph);
</pre><p><em>Detectors</em> and <em>Topics</em> are kept sorted in topological order.</p>
<p>Graph <em>Evaluations</em> start after data is posted to a <em>Topic</em>. This causes all Detector's <a class="el" href="classDetectorGraph_1_1SubscriberInterface.html#aa6ff973e38d74612e60d91f104daa624">`Evaluate()`</a> methods for that <em>Topic</em> to be called with the new piece of data which in turn may result in new data being posted to subsequent <em>Topics</em>. That may then trigger the <code>Evaluate()</code> of other <em>Detectors</em>. This process continues following the topological order until the end of the <em>Graph</em> is reached or until no more <em>Topics</em> with subscribers have new data.</p>
<div class="image">
<img src="https://google.github.io/detectorgraph/readme_graph.png" alt="digraph { FooSensorData -&gt; ThresholdDetector -&gt; ThresholdCrossing }"/>
</div>
<p> <em>Graphs can be visualized with Graphviz</em></p>
<h2>User Guide</h2>
<p>Below are a number of examples showcasing different aspects &amp; usage patterns of the framework (these are in the <code>./examples/</code> folder).</p><ul>
<li>Basic<ul>
<li><a class="el" href="helloworld_8cpp.html">Hello World</a></li>
<li><a class="el" href="trivialvendingmachine_8cpp.html">Trivial Vending Machine</a></li>
</ul>
</li>
<li>Feedback Loops<ul>
<li><a class="el" href="counterwithreset_8cpp.html">Counter With Reset</a></li>
<li><a class="el" href="robotlocalization_8cpp.html">Robot Localization</a></li>
<li><a class="el" href="fancyvendingmachine_8cpp.html">Fancy Vending Machine</a></li>
</ul>
</li>
<li>Timeouts &amp; Timers<ul>
<li><a class="el" href="beatmachine_8cpp.html">Beat Machine</a></li>
</ul>
</li>
<li>Dealing with Large TopicStates<ul>
<li><a class="el" href="portuguesetranslator_8cpp.html">Portuguese Translator</a></li>
</ul>
</li>
<li>Initial State &amp; State Persistence<ul>
<li><a class="el" href="resuminggraph_8cpp.html">Resuming Counter</a></li>
</ul>
</li>
</ul>
<h2>Porting</h2>
<p>The library has no dependencies beyond C++ &amp; STL (min C++0x) and was designed to be fully portable to any environment supporting those dependencies.</p>
<h3>Platform Implementations</h3>
<p>The library uses abstractions for basic things like asserts &amp; logging to allow for project &amp; platform specific customization. The library is shipped with a basic set of implementations for those basic functions in <code>./platform_standalone</code>.</p>
<h3>Timers / Time Integration</h3>
<p>To enable time-aware functionality (e.g. <a class="el" href="classDetectorGraph_1_1TimeoutPublisher.html">`PublishOnTimeout`</a>, <a class="el" href="classDetectorGraph_1_1TimeoutPublisherService.html#a62a05808cf040e373778fe49dc6c2da9">`GetTime`</a>, <a class="el" href="classDetectorGraph_1_1Detector.html#a61965c0d2901bae0b337bf3115187a6c">`SetupPeriodicPublishing`</a>) you must provide a concrete implementation of <a class="el" href="classDetectorGraph_1_1TimeoutPublisherService.html">`TimeoutPublisherService`</a> and pass that to your <em>Detectors</em> upon construction.</p>
<h3>Runtime Integration</h3>
<p>There are multiple ways of integrating <a class="el" href="classDetectorGraph_1_1Graph.html">`Graph`</a> into your application. A good place to start is sub-classing <a class="el" href="classDetectorGraph_1_1ProcessorContainer.html">`ProcessorContainer`</a>, adding:</p><ul>
<li>Your Detectors</li>
<li>Plumbing that connects your data sources (e.g. drivers, buttons, network) to calls to <a class="el" href="classDetectorGraph_1_1ProcessorContainer.html#a7f845054f0487426caf6b2369b07b3b4">`ProcessData()`</a> for specific <em>input Topics</em></li>
<li>An implementation of <a class="el" href="classDetectorGraph_1_1ProcessorContainer.html#a8f3cf10565478b9842e2089f2d81494f">`ProcessOutput()`</a> that links specific <em>output Topics</em> to your application's outputs (e.g. LEDs, actuators, network)</li>
</ul>
<p>A more powerful &amp; flexible option is to implement your own container to hold the <a class="el" href="classDetectorGraph_1_1Graph.html">`Graph`</a> and <a class="el" href="classDetectorGraph_1_1Detector.html">`Detector`</a> objects and orchestrate calls to <a class="el" href="classDetectorGraph_1_1Graph.html#aeab252a7ba121ea31750822bc0faf111">`PushData&lt;T&gt;()`</a>, <a class="el" href="classDetectorGraph_1_1Graph.html#a5c4388d5a8d80710bfb0a68c2b45ebbd">`EvaluateGraph()`</a> and either inspect particular Topics (retrievable via <a class="el" href="classDetectorGraph_1_1Graph.html#ac5b90d3ec0b57ff6c04a5cac1d8c687c">`ResolveTopic&lt;T&gt;()`</a>) or iterate through all modified Topics using <a class="el" href="classDetectorGraph_1_1Graph.html#ae2eea42e89f2710b5e242e3db35ad905">`GetOutputList()`</a>.</p>
<p><a class="anchor" id="building"></a> </p><h2>Building</h2>
<h3>Tests, Docs and Examples</h3>
<p>The library is shipped with a bare-bones makefile that can be used to build &amp; run all of the examples, unit tests, documentation and coverage report.</p><ul>
<li>Dependencies:<ul>
<li>Gcc and/or clang with c++11</li>
<li>gcov &amp; lcov (optional - for building test_coverage)</li>
<li>doxygen (optional - for building docs)</li>
<li>Eigen3 (optional - for building examples/robotlocalization)</li>
</ul>
</li>
<li>Building: <pre class="fragment"> # Hello World
 ~/detectorgraph$ make examples/helloworld

 # Build/Run unit tests
 ~/detectorgraph$ make unit-test/test_lite
 ~/detectorgraph$ make unit-test/test_full

 # Or simply:
 ~/detectorgraph$ make unit-test/test_all

 # Build Docs. Results in /docs
 ~/detectorgraph$ make docs

 # Build/Run Coverage test. Results in /coverage
 ~/detectorgraph$ make unit-test/test_coverage
</pre></li>
</ul>
<h3>For your project</h3>
<p>The library is mostly header-only (only 3 core compilation units) and has a trivial compilation process. So instead of providing a binary or a complete build system we recommend that users use their build system of choice to build the library in whatever way fits their needs better. For examples on how to do that, please check <a class="el" href="makefile.html">`makefile`</a>.</p>
<h2>Why another Graph compute framework?</h2>
<p><a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> shares a lot of its core concepts with other frameworks based in computation graphs (e.g. ROS, TensorFlow etc) but has also many differences. Some of its most unique features are:</p><ul>
<li>Strongly typed subscription &amp; publishing - guaranteed at compile time.</li>
<li>Per-Subscription call site at compute nodes.</li>
<li>Graph topology is dictated by combining the requirements and offerings of each compute node; no separate graph configuration/description is needed.</li>
<li>Explicit declaration of Topics provide formal interface between compute nodes.</li>
<li>Timers integration.</li>
<li>Flat design - the graph has only two types of constructs; Topics and Detectors.</li>
<li>Small &amp; Simple - it doesn't do anything else.</li>
</ul>
<h2>Style &amp; Tips</h2>
<p>For an article containing a set of guidelines &amp; rules of thumb that we accumulated after 3+ years of using <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> visit <a class="el" href="ssg-style_suggestions.html">Style Tips - Patterns, Anti-Patterns &amp; Suggestions</a>. These are aimed at keeping software design constrained in a way that best takes advantage of the <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> framework, its expressibility and modeling power.</p>
<h2>Naming</h2>
<p>The <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> library had a little naming problem growing up. From birth it came to replace nlDetectorGraph and so it pretended to be called that way. As an adolescent it decided it wanted to be called MarkII.. but no one cared - for years now the world continues to call it simply <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a>. Now as it approaches adulthood it has finally accepted its popular name: <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a>.</p>
<h2>In-depth Docs &amp; API Reference</h2>
<p>For in depth documentation of the library, <a class="el" href="core_introduction.html">start here</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
